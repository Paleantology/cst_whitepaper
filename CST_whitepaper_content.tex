\definecolor{armygreen}{rgb}{0.29, 0.33, 0.13}
\newcommand{\aw}[1]{{\textcolor{armygreen}{[AW: #1]}}} % %AW comment
\definecolor{amethyst}{rgb}{0.6, 0.4, 0.8}
\newcommand{\sarah}[1]{{\textcolor{amethyst}{[SF: #1]}}} % %SF comment
\definecolor{teal}{rgb}{0.0, 0.5, 0.5}
\newcommand{\rs}[1]{{\textcolor{teal}{[RS: #1]}}} % %RS comment
\newcommand{\rsedit}[2]{\sout{#1}{\color{teal}{#2}}}
\definecolor{pauburn}{RGB}{184,90,13}
\newcommand{\jo}[1]{{\textcolor{pauburn}{[JO: #1]}}} % %JO comment
\newcommand{\jedit}[2]{\sout{#1}{\color{pauburn}{#2}}}
\definecolor{blue}{rgb}{0.0, 0.0, 1.0}
\newcommand{\cn}[1]{{\textcolor{blue}{[CN: #1]}}} % %CN comment
% find colors with percents at https://www.december.com/html/spec/colorrgbaper.html

\begin{itemize}
\item [\textbf{TODO}]
    \item \aw{I cleared out some of the edit marks so it is a little easier to see. I was feeling a bit distracted by them in some places, especially where the text is a little more final. I did a commit right before, so all the comments are preserved.}

    %\item \rs{Make sure article is framed around new title}
    %\item Citations in the introduction \sarah{I added a bib file with the references I cited in section 5, others should feel free to add to it}
    \item \rs{where is this being submitted? PeerJ?} \cn{PeerJ sounds good to me... Are there funds available for the OA pub fee?} \rs{I can put in a significant part. I was wondering if anyone knows where this fits best - it's not research, not quite review, a bit like the 10 Simple Rules papers but those all seem to be in PLoS Comp Bio, which is narrower} \aw{I'm open for discussion on this! I like PeerJ, just because its free to read without being super high cost for us, but realistically, I have a big chunk of money I can use for this, and iEvoBio can kick in some, too.}\cn{Chiming in to say I don't have strong feelings about venue... it's also not an important factor for my PandT committee.}
    \rs{I am good publishing whereever - I was wondering who accepts this sort of article. Might look at F1000 research as well, or a teaching journal eg The American Biology Teacher} \aw{I'd be really interested in F1000, since the model is kind of cool, but it looks like they don't do review. I can send an inquiry, though}
    
    \item \aw{Student --> learner}
    %\item Maybe add an equity and inclusion call-out box on cultural issues surrounding asking for help -- what do others think of this idea? \sarah{I can start this on 8/28} \aw{This is a really nice idea!} \rs{my colleague Bryan, who studies inclusive education, says this is a good point - he suggested looking at John Henryism, Treisman 1992, and part 2 of https://www.thisamericanlife.org/550/transcript} \sarah{great suggestions!}
    \item \rs{thoughts on consistency and scaffolding of computing platforms}
    %\item \rs{wondering if we should discuss languages up front as it's kind of key and gets discussed in terms of using RStudio/Jupyter but that's not exactly logical} \aw{This is an interesting point - a lot of biologists learn and use bash, but we don't even mention it other than obliquely} \rs{I was just about to say we need to include bash, especially as that ties in to Raspberry Pi and/or genomics} \rs{maybe before platforms talk about languages} \aw{Discussion welcome from everyone on this point! I like the idea that }
    \item \rs{thinking we could use some details - maybe boxes of summarized case studies; also suggestions of where instructors get data and/or lesson plans eg QUBES} \aw{I really like this idea!} 
\end{itemize}


\section{Abstract}\label{sect:Abstract}

Stuff about computing.

\bigskip


\bigskip
\section{Introduction}\label{sect:Introduction}

\rs{Lots of good refs in Madlung 2018. Also, perhaps someone can smooth out the writing of the intro - I think most of the content is there but it's a little choppy.}

Biology departments are increasingly offering or considering course work incorporating hands-on computation
\citep{WilsonSayres18}. 
There are different rationales for courses that include computation.
Perhaps the most obvious rationale is to teach computational biology, bioinformatics,
and/or skills in working with large datasets.
In such courses, instructors may be teaching particular skills or tools that are an integral part of the field.
Bioinformatic skills are increasingly a core component of biology and biology education, and 
support students' job and/or graduate school preparation \citep{WilsonSayres18}. 
The vast majority of researchers in biology either use large datasets or could do so with sufficient training, suggesting that general training in effective use of large datasets is essential for students as well \citep{Barone17,Loman13}.
An alternate motivation is to incorporate more data and analysis into course work.
Integrating data into courses provides more opportunity for students to experience the research process, and the ability to incorporate active learning activities where
students recognize biological theories by drawing conclusions from their own results
\citep{Kjelvik19}.
Another rationale for teaching computational skills is to increase data literacy \citep{Gibson18}, which, in addition to enhancing learners' preparation for future careers, also better prepares learners to think critically about societal issues relevant to science and policy \citep{cook2014}.

However, there are significant barriers to teaching hands-on computation in biology classrooms \citep{Williams17}.
While many biologists use computation in their research, relatively few have explicit training in computation. 
Fewer still have training in how to teach computation \citep{Williams17}.
Importantly, few biologists are housed in a department with the existing expertise or infrastructure for teaching computation \citep{Williams17};
thus, there is often less familiarity with options for teaching computing or recent best practices. 
\citet{Cummings10} describe the challenges in teaching bioinformatics as 
``infrastructure and logistics; instructor knowledge of bioinformatics and continuing education; and the breadth of bioinformatics, and the diversity of students and educational objectives.''
\citet{Williams17} similarly cites faculty training, infrastructure, and student interest and preparation.
Here our goal is to address issues of infrastructure and logistics,
and make recommendations for faculty practice.
We suggest that those seeking training consider programs such as Software and Data Carpentry workshops
to address the issue of faculty training.
%We do not address issues of instructor knowledge of computing; thus, we are aiming primarily at 
%faculty with at least some computational skills and an interest in integrating computation into their courses.
%Williams: lack of faculty training, lack of student interest in bioinformatics; lack of student preparation in mathematics, statistics, and computer science; already overly full curricula; and limited access to resources,
This review explains options available for instructors to teach computational course content
(collectively referred to here as computing platforms),
discusses how to choose the best computing platform for a course, 
and describes effective strategies for teaching coding and data analysis.


%rs: this is the how section
An important consideration is that the technology an educator uses to deliver their content supports the educator's learning objectives and enhances students' ability to learn. 
Every course has a unique set of learning objectives, and
every group of learners poses a unique set of challenges. 
Such learning objectives related to computing may range from engaging students in the value of basic coding skills to building advanced skills and the ability to self-teach and work independently.
An example of the former might include a freshman introductory biology lab focusing on data analysis, where students focus on the results from the data analysis. 
In contrast, an upper-division course on research methods may focus more on preparing students for independent data analysis by emphasizing self-sufficiency in coding, and software management and installation.
Additionally, the selected platform needs to support the type of work the students are doing.
In the first example, students might need to learn to make appropriate plots to visualize biological data; thus, the platform students work with needs to have the capacity to display plots.
On the other hand, if a course objective is for students to learn to manage genome-scale data on a remote server, a platform using a command-line interface to access a computing cluster may be more appropriate.

Much as a biology laboratory course requires specific laboratory equipment, teaching computation requires learners to be able to access specific software and functions.
This may range from one or a few pieces of software that can be downloaded from the internet
to installation of a computing language and development environment.
For simplicity,
the interfaces used by learners and the instructor should be uniform, as different versions of software could have different interfaces or commands.
Learners also need  a way to compute outside of class -- for example, to do the homework outside class hours.
Finally, the computing platform should allow students to focus on the coursework and instruction. 
The learning platform must not interfere with students' focus on the learning objectives.
%\rs{something about it's worth considering these ideas and choosing a platform that facilitates learning}

Another consideration is the consistency and scaffolding in selecting tools and/or the larger platform.
\citet{Gibson18} cites the need for ``coordinated, sequential development of data literacy across the biology curriculum'',
which suggests the value of a platform and tools on which students can scaffold their skills,
rather than each course choosing its own tool.
For example, students would likely find it challenging to use R in one class,
Python in another \citep{wu1990}, and a genomics platform such as Galaxy in another.
%\rs{cite Guzdial on difficulties switching languages} \aw{so I think that Guzdial post is just a synthesis - I found the original article he was quoting from (it's a thesis). Feel free to correct if I'm wrong, though.} \rs{could be - I don't remember details just that he's discussed issues of transitioning languages and I thought that's a worthwhile point to mention}. 
Furthermore, switching languages and platforms (i.e.\ learning a new skill set)
can detract from time spent on other educational activities when the goal is not to explicitly teach the language or platform.

Every choice of computing platform comes with costs and benefits. 
In this review, we will discuss tools and techniques to facilitate teaching computation in courses with some degree of programming or data analysis.
We explain different computing platforms with a special eye towards serving diverse sets of learners, 
in terms of their motivations, life experiences, and access to technology.
In particular, we will focus on programming languages that are common in biology, R and Python. 
Lastly, we review effective pedagogical techniques for helping learners thrive in a computational classroom.

\section{Choice of computing language}

One of the first choices an instructor needs to make when they plan coursework is what computing language to use.
In biology, R and Python are common languages.
Bash, a type of UNIX command-line language, is commonly used to run software and automate tasks.
There are multiple considerations to take into account for this choice.
In particular, taking into account \textit{consistency}, \textit{current status of research tools}, and \textit{comfort} will make this choice easier.
\textit{Consistency} refers to consistency of the language's use throughout the curriculum.
Prior research \cite{wu1990} indicates that switching languages can be associated with learning loss in novices.
Therefore, in order to deepen and strengthen learners' command of languages, integrating the same language consistently throughout the curriculum may be helpful.
For example, if an instructor is integrating a computational component into a genetics lab, they might check with a colleague teaching biostatistics or bioinformatics to see what language they are using.


The \textit{current status of research tools} is also worth considering. 
If the goal of a course is for learners to understand both biology and computation, the instructor will want to choose a language with active development of tools for research in that field.
For example, many genomic and phylogenetic tools are written in Python. 
On the other hand, more ecological and comparative biology tools are written in R.
%\rs{There are how-tos for both}
Therefore, the choice of language will inform the subset of tools available to the instructor and the learners.
Finally, instructors should consider their own \textit{comfort}. 
Teaching requires fluent and comfortable discussion of concepts and tools.
Instructor knowledge must factor in to this.
Additionally, community resources exist for some languages. 
For example, QUBES is a National Science Foundation-sponsored (NSF) project that publishes lessons and sponsors instructor mentoring groups in various scientific disciplines.
An instructor may feel more empowered to teach well if there is a strong sense of community in their language, with pathways to ask for help and access resources.

It is also worth noting that not all tasks that are computational necessitate the addition of programming into the curriculum.
For example, tools such as the NSF-sponsored Galaxy project allow instructors to help learners run bioinformatic and genomic software via a point-and-click internet interface.
If the goal of a course is to demonstrate answering a particular question, but not to dig too deep into the methodology of how that is done, this type of interface may be sufficient.
Teaching with these resources, however, is beyond the scope of this article.


%\rs{Why R, python, bash; what about genomics/web tools eg Galaxy}
%\aw{I'm debating with myself about what I think should go in a section like this. To some extent, these tools are here because there languages have caught on really well. The tools have caught on because of the type of teaching they enable. You conceptually can teach C and C++ in a Jupyter notebook - but I don't know anyone who does. Perhaps we could have this section address the scope of the review. Maybe}

%\aw{I think whatever we want to do, we want to keep fairly brief}
%\rs{maybe move this to intro? I agree about outlining the scope and including all this should help. My thought about a section on programming language is that we talk about local installs but not what we're installing. Then talk a bit about python/R in those sections but that's way later. I'm trying to outline some pros/cons of the languages. What specifically helps support student learning or future research work. Could mention something like Galaxy here and explain pros/cons then say we won't discuss further.}
%\aw{I went ahead and integrated the `scope' stuff into the intro. It's a more effective closing paragraph than what was there. I changed this section header to `Choice of computing language', which might frame things more effectively - not so much what language is `best', but which supports the learning goals of the instructor?} \rs{sounds good}


The R language allows inexperienced learners to immediately work with rectangular (i.e.\ spreadsheet-style) data in a way that is engaging. For example, a learner can load data and plot results within an hour of first opening RStudio. This engagement is important for learners who are more interested in working with data effectively than learning to code. We suggest that the R language immediately supports coding-to-learn with minimal learning-to-code \citep{}.
%\sarah{Perhaps 'biological data' would be better than 'rectangular data'?}
%\rs{I support rectangular data, as biological data comes in a lot of different forms (eg genomic sequences); however, this should definitely be defined more clearly - can be described as something that looks like a spreadsheet}
\aw{What if we called it "spreadsheet data (often referred to as `rectangular data'"?}
\rs{whatever seems clear}
\rs{R might fit better if students take stats}
\rs{tidyverse has enabled ease of use, and can even be used for accessing databases easily}

Python is a widely-used general purpose programming language.
Python is widely used in a variety of industries (https://stackoverflow.blog/2017/09/06/incredible-growth-python/).
Python can be adapted to many purposes. 
For example, the popular data science library Pandas (cite pandas), can be used for teaching foundational data skills.
Python also has a variety of resources for teaching work with non-spreadsheet data.
BioPython is a library for working with general sequence datasets at a variety of scales. 
More specialized libraries, such as Poretools (for Nanopore data) or Dendropy (for phylogenetic trees) are also available for work in subdisciplines of biology and bioinformatics.

Depending on the aims of the class, it may be necessary to choose a supporting language, as well.
For example, in contrast to a code to learn course in which biology students practice drawing conclusions from data, a course on genomics might require students to interact with large datasets on a remote server.
Many such servers require a UNIX command line to access.
While this review will focus on R and Python, some instructors may find that they need additional languages to support student learning, particularly in advanced disciplines.


\rs{I find this section helpful}

{\begin{framed}
\textbf{\centerline{Case Study call out box! }}
\rs{need a different color for case studies}
\begin{snugshade*}
Example of how R can be used in intro bio for data analysis. Immediate plotting: what R does that Excel doesn't. Choice of R for rectangular data. Scaffolding. Tutorials. Support outside class.
\end{snugshade*}
\end{framed}}

\section{Local Computing Platforms}

\subsection{Local Installs on Personal Computers}\label{subsect:Local Installs}

Perhaps the most basic computing platform setup is to have students install languages and software locally on their own computers. 
Local installs may work best in small classes that focus on 
%the basics of 
coding, where the goal is to have 
%for students with no prior experience. 
%\rs{I'd agree with small classes, but for students with no prior experience I typically aim to avoid having them install anything as it's challenging}
\aw{Perhaps 
students who leave the course self-sufficient to do computational work.}
\rs{recommend installing Anaconda, Jupyter, R, RStudio, etc. and explain how these enable package mangement}

\subsubsection{Advantages of local installs}

Local installs allow students to immediately be able to apply their new knowledge of code outside the class without additional support. For students who are already familiar with their own computers and operating systems, having students use local installs can bypass some of the learning curve associated with learning a completely different platform; this also applies for instructors, who often have limited time to devote to learning a new platform exclusively for the purpose of teaching a course.
\rs{I feel this statement needs a ref}

If the software used in class does not require a paid license or subscription, students will continue to have access to the specific tools used in class after the course ends. Teaching students with tools that they know they will be able to take away with them and apply in the future increases student motivation to learn these tools and increases the chance that they will actually use them in future work.

Local installs are a solution in particular for smaller institutions that do not have access to remote computing platform. In some cases, though setting up a computing platform may be theoretically possible, it may not be feasible within the constraints of resources, time, and IT personnel. Local installs offer an alternative system that does not typically require extensive coordination with IT personnel at an institution.

\subsubsection{Overcoming the challenges of of local installs?} 

While using local installs can minimize time spent learning new platforms, it may also extend the initial time spent setting up students' computers for the course -- namely, with language and software installation. The feasibility of using local installs may thus be limited in many cases by class size. This up-front time can be minimized by having students complete as much installation as possible before the course begins
using detailed instructions or videos, which are already available \rs{maybe note where}.
However, students who have little or no prior coding experience may struggle with some installations if no guidance is provided. In addition, troubleshooting installs on various platforms can be challenging, especially with a larger class working on a wider variety of computers. 
In some cases, software may not be available for a particular platform (e.g.\ RStudio on Chromebooks).
Further, if students have previously installed a particular language, IDE, or package, they may have a different version than that used in class, which may complicate analyses later. This issue would present less of a problem in classes that primarily cover the foundations of coding, and/or with students who have little to no prior experience.

In classes that have students do analytical work requiring substantial computational power, students may not have computers that are able to do that work. Some students may not have computers at all. For these reasons, local installs may not be the best option for a required course (i.e., if a student must take the course regardless of whether or not they have a computer they can bring to class) or for a course where a substantial amount of time is spent on computationally intensive work. For elective courses, the instructor may choose to list a computer as required material for the course and make that information available to students during the class registration period. However, this requirement limits the students who are able to take the class to those who have a computer to bring. With small classes, it may be possible to provide a computer to a student who does not have their own, and the instructor should also ensure that the student has access to a computer outside the classroom with necessary software for homework. An alternative solution may be to hold the class in a computer lab, but installation of software in computer labs may require IT support, depending on the institution.

\subsection{Single-board computers (SBCs)}\label{sbc}

%\rs{I feel like we could be up front about suggesting this as an amazing tool for more advanced computational biology with limitations at the intro level. I do wonder how much you could do with these as sensors in the field without teaching advanced computing skills for more integration of data in the classroom, but I feel like that's a tangent.}

Single-board computers (SBCs) are minimalist complete computers built on a
singe circuit board.
There are a number of organizations in the single-board computer market, but
they were first popularized by the the Raspberry Pi Foundation.
The most basic SBC models cost as little as \$10, and offer WiFi, Bluetooth,
and quite high-performance computing.
%\rs{also you can get a pretty solid computer for \$99}
Generally, a Linux distribution, such as Raspbian, is installed
on a microSD card and run on these machines.

An SBC is not immediately useful on its own, because it does not have a monitor
or input devices.
However, these machines can be used
(1) as a server, by logging in ``remotely'' from another machine via WiFi or
wired connection, for example, using secure shell (SSH) protocol,
or
(2) as a standard Linux PC, by booting into the desktop environment and using
attached input and output devices (e.g., monitor, keyboard, and mouse).
Having students use SBCs shares some similarities to using local
installs, in the sense that the students can run software installed on their
own local machine.
However, SBCs would ensure that all students are using the same
computing environment and have the same capabilities.
%\rs{This is true if they buy them as part of a course requirement, which is reasonable given the cost is less than most textbooks}
Furthermore, SBCs can be used together with all the other computing platforms we
discuss here.

\subsubsection{Advantages of SBCs}

Teaching with SBCs can be particularly effective at an institution with limited
IT support.
Even in a classroom without reliable internet, the instructor can set up an SBC
as a local network for sharing code and data among the students.
Thus, they can also be used in teaching environments not traditionally thought
of as computing-friendly, such as in the field.

SBCs can be particularly good tools for teaching students how
to use remote Linux servers and HPC resources.
Remote computing can be an abstract concept for students with limited
computational background.
Showing students how to ``remotely'' login from another computer to their SBC
they they have in-hand can make the idea of remote computing much more
tangible.
Furthermore, SBCs offer a way of teaching high-performance
computing when such resources are not available.
Even institutions with HPC facilities often do not support the use of these
resources for teaching.
On a very modest budget, an instructor can set up a shared, ``mini''
computing cluster to teach fundamental principles of HPC, such parallelization,
message passing, and scalability.

One particularly exciting pedagogical opportunity presented by SBCs is
the integration of tech and computation to create biology curricula needed by
students in the 21st century.
Imagine a scenario where all students entering a program would receive an SBC
along with some basic training on how to use it.
Because SBCs allow direct access to the computing board and
associated headers and ports, they are extremely modular, and can be coupled
with many inexpensive accessories for collecting data.
For example, for as little as \$40, one can purchase an add-on board that
includes a variety of sensors, including a gyroscope, accelerometer,
magnetometer, temperature, barometric pressure, and humidity.
Students using these devices could collect observational or
experimental data in the lab of their introductory biology classroom.
Then, in a lecture or discussion session, they could learn to use basic
scripting to process, visualize, ``clean,'' and analyze those data.
If an undergraduate or graduate curriculum was designed for the students to
continue using their SBC, data, and scripts throughout their coursework, this
could be a powerful approach to training the next-generation of computationally
competent biologists.
The development of such a curriculum goes far beyond the scope of what a
typical teacher needs from a computing platform.
Nonetheless, this aspirational idea is worth highlighting when discussing
SBCs, because they can be used jointly with all the other computing platforms
discussed in this paper.


{\begin{framed}
\textbf{\centerline{Diversity and Inclusion call out box!}}
\begin{snugshade*}
%\rs{can someone fix the indentation? Also, is there a way to make the box title look like a title?}
%\aw{how about this format?}
The low cost of high-performance, single-board computers (SBCs) can make the
classroom more equitable. With a cost as low as \$10 per computer, it requires minimal investment from students, or, more ideally, increases the likelihood that an institution or funding agency can cover this cost. Using SBCs also ensures that all students experience the same computing environment and capabilities. Furthermore, the low cost can allow the students to keep the computer after the course is over. This can enable life-long learners across all socioeconomic backgrounds.
\end{snugshade*}
\end{framed}}

\subsubsection{What are the disadvantages of SBCs?}

The initial setup of an SBC requires time and effort to install the
Linux distribution on the microSD card.
If the primary goal of the course is to use technology to teach biology,
this work should be done by the instructor prior to the class.
If the class is large, this would most likely require IT support to pre-install
the operating system on many microSD cards.
However, if any of the learning objectives of the course involve
a better understanding of operating systems or computer hardware,
turning the initial setup into an active-learning exercise done
at the beginning of the class could be a very informative
learning experience for the students.

Even after the initial setup, SBCs are not immediately useful on their own.
The students require either another computer to login to the SBC via SSH, or
peripherals (e.g., monitor, keyboard, and mouse) to use the SBC as a PC.
By the time these peripherals are factored in, the total cost could become
similar to an entry level laptop.
However, the students can benefit from the modularity of the SBC system.
The peripherals can be re-used, and the students could keep the SBC itself.
This is not possible with laptops.

When not used as a PC (i.e., without peripherals), using an SBC can be
quite unintuitive for students not familiar with the Linux command line.
For example, it would be counter-productive to take the time necessary
out of an introductory biology class to teach students to become proficient
in using an SBC from the command line.
While this weakness can be overcome by using the SBC as a PC, this option does
require additional investment and logistics to provide the students access to
keyboards, mice, and monitor.


\section{Cloud-Based Computing Platforms}

A number of platforms for serving course materials via the internet have become available. 
Since these technologies share many similarities, we will first discuss these computing platforms generally,
then discuss teaching with R and Python in the cloud.


\subsection{Advantages of Cloud-Based computing platforms}\label{subsub:cloud-advantage}

Cloud-based systems typically provide a web interface to a centralized version of an IDE. This 
allows the instructor to set up a uniform instance for all learners, avoiding time spent sorting out problems, such as learners having different versions of languages or software installed.
Students can then focus on learning biology and/or working with data, rather than on managing technical details.

Cloud-based computing platforms also ensure that learners
are not limited by their hardware or software. The instructor sets up the class software on a server, rather than the learners installing software on their own personal machines, thereby avoiding problems such as learners not having computers powerful enough to run exercises, or computers without the ability to do language installs (such as NetBooks). This can be especially important for serving students who have difficulty purchasing a personal laptop to bring to class.
%of lower socio-economic brackets.

Many cloud-based computing platforms are agnostic to the type of machine on which they are run. 
For example, JupyterHub and RStudio Server can be deployed on any machine with Unix or Linux supported. 
This machine can be owned by an instructor, a high-performance cluster (HPC) computer operated by a university, or cloud 
computing resources rented by the instructor.
The main considerations for what type of machine to run the a cloud-based computing platform are memory, storage, and access.
For courses with low-memory tasks, such as data processing on small datasets, a single machine may be sufficient, even with large numbers of users.
For high-memory tasks (such as genome assembly), or tasks that with long runtimes (such as phylogenetic estimation), 
cloud compute resources that can be resized from week to week may be more suitable.
For example, platforms such as Digital Ocean and Amazon Web Services allow users to pay for more memory only when needed. 
The server can be resized between class periods to allow more memory to be available to learners.
This flexibility can allow an instructor to run a course on the resources they have available to them, based on their available infrastructure and funds.

Many faculty will require IT support to set up the server, especially if the server is used by a large population. However, in our experience once setup is complete, maintenance requires minimal time and having IT handle upgrades and additional users relieves faculty of some work. The size of the server required for even large numbers of students to do analyses can be quite minimal (e.g.\ just 4 cores for hundreds of students) provide they are conducting analyses of relatively small datasets (e.g.\ hundreds of samples). 

\subsection{Disadvantages of Cloud-Based computing platforms}\label{subsub:cloud-disdvantage}

While the cloud-based computing platforms are a flexible tool for teaching, there are some downsides.
Because students typically interact with the server via a web-based login, if university resources are to be used, 
instructional technology (IT) staff will typically want to be involved.
Some universities do not allow public-facing servers to be operated by non-IT staff, which can 
limit instructors from using computers they have on hand to serve their coursework.
Likewise, due to security concerns, it may not be possible to operate a server on a university HPC.
In this case, the instructor will likely have to turn to cloud compute providers.
Many of these providers are affordable for small classes or low-memory tasks, but costs will scale with users, storage, and memory requirements.

These technologies do interact with the internet.
Therefore, when problems arise in the classroom, the instructor must distinguish between problems with the server itself, with a 
learner's computer, and with other classroom technology, such as wireless internet.
While internet-based technologies can increase for equity and inclusion by allowing learners to 
interact with the course materials no matter how old their computer is, or in the case of  unstable computer access, 
they increase the complexity of diagnosing performance problems.
Unstable internet connections can cause many, if not all, members of the class to lose connection to the materials during class.
Students with individual computer problems, such as malfunctioning wireless cards, may need to borrow a computer to access materials. 
If the instructor is teaching without IT support, they may need to halt class and fix problems if the server itself is malfunctioning.

Additionally, because a server facilitates students focusing on the data
and analyses, rather than installation and troubleshooting, students may leave
class without the ability to work independently outside the classroom.
They have not learning how to install the programming language or IDE, and these 
are not installed on their personal computer.
Additionally, they do not have or know how to install supporting packages.


\subsection{RStudio Server}\label{subsub:RStudio}

%\begin{itemize}
%\item When should you choose to use RStudio Server?


RStudio Server provides a web interface to a centralized version of the RStudio IDE for working with R code. By using RStudio students are able to simultaneously view their script, environment variables, file structure, plots, installed packages, etc. The Server format allows the administrator to maintain a consistent version of R, RStudio, and installed packages. This approach allows beginning coders to focus on data and results, rather than worrying about installation and versions. It allows an instructor to be sure that students can focus on their code without being limited by their hardware or software.
\rs{some of this might be redundant with the general description of the servers above} \aw{I think the repetition is light enough that it works - we're targeting an audience that might not be familiar with any one of these technologies}

RStudio also has a command line built in, so the server can be a great way to teach command-line and bash scripting work.
\rs{should probably expand or clarify this in some way}
\rs{add level of detail to match Jupyter}
\aw{Perhaps something about integrated revision management? It's a very painless way to learn intermediate skills like versioning.}
\rs{I wasn't going to get into version control - it seemed like too much - what do you think}
\aw{I don't think it matters much. I was thinking I might throw in a line under Jupyter to note that a fully-functional terminal emulator allows for incorporating the kind of "high novice" skills like revision management}


Some advantages of RStudio Server is that students data and code is stored (and backed up) on the server. 
Instructors can also access a student's code from anywhere to help students solve problems remotely.
RStudio Server is free for teaching purposes.
Additionally, for smaller scale teaching an instructor may use RStudio Cloud, which provides a free ready-to-go web-based version of RStudio.

{\begin{framed}
\textbf{\centerline{Diversity and Inclusion call out box!}} 
\begin{snugshade*}
A local RStudio Server or JupyterHub reduces barriers to the use of R or Python and support underprivileged students by removing the requirement to have a laptop (a Chromebook or tablet is sufficient) and minimizes the frustration associated with installation and different operating systems. Students can access the server from any location via a web browser using any machine while experiencing a consistent interface and access to their code and data. 
\end{snugshade*}
\end{framed}}

\subsection{JupyterHub}\label{JupyterHub}

Project Jupyter is a non-profit organization that creates open-source tools for computation.
One of their most famous products is the Jupyter Notebook, which allows researchers to create interactive code documents.
These documents can have text, images, and code cells that run and render output for inspection.
The Jupyter Notebook was originally developed as the iPython notebook, but has since expanded to include language support for other popular languages such as R and Julia.
A JupyterHub is a server on which an instructor can deliver lessons via Jupyer Notebooks to a full classroom of students using a standardized server environment.
In most cases, the server will be accessed via the internet.

A JupyterHub typically has four components. 
\textbf{The Hub} itself coordinates user log-ins and spawns \textbf{single-user notebook server (SUNS)} for learners to use.
These SUNS allow learners to access the Jupyter interface and course content.
By default, these are intended to be private, and to enable a learner to save their work on the JupyterHub for later retrieval. 
\textbf{The proxy} receives input from the learner via their Jupyter interface. 
When a learner enters information in their notebook, runs code, or renders text, the proxy passes the commands to the Hub to execute. 
Lastly, \textbf{the authenticator} handles the log in of accounts.
This ensures that only authorized users can access the JupyterHub. 

\subsubsection{What are the advantages of a JupyterHub?}

The first and foremost reason to use a JupyterHub is that you want to teach with the Jupyter ecosystem of tools.
The Jupyter Notebook is commonly used in education in the sciences.
It allows the instructor to develop a set of instructional materials that include text, code, and images.
In this way, detailed notes can be provided from the instructor to the learner, and the learner can augment these lessons with their own notes, annotations, and code.
Though originally invented for use with Python, Jupyter Notebooks are compatible with a number of languages.
Multiple languages can even be used in one notebook, making them ideal for use with multi-language pipelines.
The JupyterHub also has a command-line terminal and the Git revision management system installed, for more advanced courses.

All four components of the JupyterHub are configurable.
This makes the tool very extensible. 
For example, a small course can often use a single computer to manage users.
A course with many students or heavy computations can take advantage of different spawners to use compute resources effectively.
Likewise, different authentication systems can be used if different levels of stringency for server access are required.
While a JupyterHub does require an internet connection to use, course materials can be downloaded by learners to interact with the materials offline. 
In sum, this is a flexible tool, and one that allows an instructor to scale their course service as the number of students and the computational demands of the material fluctuate. 


{\begin{framed}
\textbf{\centerline{Diversity and Inclusion call out box!}} 
\begin{snugshade*}
Server-based computing platforms allow learners to access course materials via the web. The actual computations performed via a JupyterHub or RStudio Server are carried out on a remote machine. This can level the playing field for students who may need to access their coursework on multiple computers (such as students relying on computer lab or library access to machines) and students who have old machines or other limitations such as Chromebooks.
\end{snugshade*}
\end{framed}}

\subsubsection{What are the disadvantages of a JupyterHub?}

Jupyter supports the R language.
However, the interface for R in Jupyter is different than RStudio, a dominant way to interact with R.
Likewise, the JuptyerHub does not support other popular integrated development environments (IDEs), such as Python's Spyder.
While there is a text editor for preparing scripts, and a command line to run scripts, the JupyterHub is really designed to serve Jupyter Notebooks, and the interface caters to this technology.

%TODO:
% Call-out box explaining which technologies are provided by non-profit and which are for-profit, and what this can mean for users? 


\subsubsection{HPC and Cloud}\label{HPC}
\rs{maybe move this section up to where you discuss servers generally as you have some cloud stuff up there}
\aw{I was thinking kind of the same thing ... I like the idea of this content coming after the descriptions of the platforms because it's sort of the nuts-and-bolts. But I also agree that there are earlier points where it could make sense. I might print out the MS both ways and see}

RStudio Server and JupyterHub will typically require that instances are \textit{hosted} somewhere.
This refers to having the compute platform installed in a central location, at which it can be accessed by all students.
It may be possible for an instructor to host an their course platform on a computer or server they personally own.
However, many universities prohibit faculty from hosting servers on-campus that will be available off-campus due to security concerns with allowing off-campus computers to access on-campus resources.
This means that you may be able to host a server via the intranet, but if students go home for the weekend, or live off-campus, they'll need to come back on to campus to do their homework.

These limitations cause many instructors to look for alternative ways to provide their course platforms to students.
One common way is by working with a local high-performance cluster compute facility.
A high-performance cluster computer is a set of computers that are networked. 
This allows researchers to harness the power of several computers at once.
These facilities often also service educators.
A benefit to serving course content via high-performance cluster computing is that these resources are often free for educators at the university where the computer resides.
Because these services are often in-house, the administrators of them are able to handle any specialized security concerns with the course platform.
National level high-performance cluster computers, such as CIPRES, JetStream and CyVerse also offer resources for US institutions.

However, not every university has a high-performance cluster computer that is set up to host coursework. 
In this case, an instructor may want to consider a cloud-based solution. 
The concept of a cloud-based solution is similar to using high-performance cluster computing.
An educator can rent one or more computers to serve their coursework. 
Cloud computing can take several forms. 
In some cases, the instructor explicitly rents computers in sizes that are appropriate for their course.
These types of services often charge by the number of computers, the size of the hard drive rented, the amount of memory on the computer, and the amount of time for which they will run.
Examples of this type of service include Digital Ocean, Cloud Flare, and Amazon Web Services.

{\begin{framed}
If you are signing a contract for cloud services, it is prudent to check with both your IT department and legal. 
Both departments may have rules in place for student privacy and data security, as well as for contract bids between providers.
\end{framed}}

Recently, educational cloud service providers have entered the market.
Examples of these services include RStudio Cloud and Python Anywhere. 
These types of products are oriented towards providing an environment that is oriented towards a specific language or course platform. 
For example, RStudio Cloud hosts RStudio instances, and Python Anywhere hosts a variety of Python environments, including Jupyter notebooks. 
Like an regular cloud provider, these services typically charge based on the size of the amount of memory and storage capacity of the computer needed.
Being oriented towards education, some of these providers also offer accounts for free, with paid accounts available for users who need more memory or computer power.






{\begin{framed}
Diversity and Inclusion call out box! 
\begin{snugshade*}
Cultural issues surrounding asking for help.
Asking for help is critical for students to be able to overcome confusion, solidify their skills, and deepen their knowledge and understanding. However, cultural differences exist that may prevent students from seeking help, even when they need it most. 
\sarah{I need to add information from some readings}
\end{snugshade*}
\end{framed}}

\subsection{Bridging the gap between local and cloud-based approaches}

%\jo{Containers could be a separate computing platform section, but it seemed relevant here.}
%\rs{I like all this, but do feel it should go elsewhere - perhaps after cloud due to the comment about bridging the gap}
%\aw{now that I'm reading through, I think after cloud is probably the place to put this}
%\jo{I agree. This was up in local installs; moving it down here and rewording a bit.}
Container software, such as
Docker,
Singularity,
or
Podman,
offer a way to \rsedit{bridge the gap between}{} teach\rsedit{ing}{} with \rsedit{}{the simplicity of }local installs \rsedit{and}{while utilizing the consistency of}
cloud-based computing platforms.
Containers allow the instructor to create a standard computing environment that
each student can work within on their own computer.
Instead of having to install multiple tools that will be used in the course,
the students would only have to install the container software (e.g., Docker,
which is cross-platform), and then they can download and run the environment
created by the instructor.
The functionality is very similar to a virtual machine, but lighter-weight and
more efficient.
Containers can be easily updated and distributed with cloud-based
services like
\href{https://hub.docker.com/}{DockerHub}.
This allows the instructor to update the students' computing environment in
real-time.
Of course, this still has the same disadvantages discussed above of having
students run analyses on their own computer.

\section{Teaching methods}

%\sarah{I've restructured this section to group various methods by type}
%\rs{something about beyond the technical logistics of installs or setting up, it's helpful to think about how to teach computation in biological courses}
%\sarah{I definitely agree that this section needs an intro to integrate it with the rest of the paper.}
%above commented out as this seems to be taken care of

Designing an effective biology course that incorporates computing requires more than choosing the best computing platform for your needs. Skills-based courses such as coding necessitate a unique approach to teaching that can differ in some ways from more commonly used pedagogy in content-based courses. 
For many students, a biology course that involves hands-on computing may be their first classroom experience that heavily involves learning increasingly complex skills that build off of each other, rather than primarily learning content. And similarly, instructors whose research and teaching expertise is in a field that is not strictly computational -- which likely includes most instructors of biology -- may benefit from guidance on best practices for delivering content effectively and addressing the unique challenges that arise. As a skills-based discipline, computation 
%\rs{I would avoid a narrow focus on comp bio and broaden to allow any course with computing such as data analysis} \cn{Agreed - I changed "computational biology" to "computation"(is that considered a discipline, or should we change that wording?)} 
necessarily requires some level of active in-class interaction from students (with the instructor or peers, or with the material itself). Thoughtful implementation of appropriate active learning strategies has been shown to increase both mastery of content and development of general skills such as critical thinking and collaboration \citep{faust_paulson_1998}. Below, we describe several strategies for teaching coding and address challenges that instructors may face in teaching a course that is perhaps more similar methodologically to math and foreign language than to other biology courses.

\subsection{Example-Based Learning}

Example-based learning has a long history in teaching coding, and consists of the instructor providing examples of how to solve a given problem using code.
Sometimes, these examples are static and provided in a textbook or on slides. 
Other forms of example-based learning requires the students to actively engage with the code. 
An especially effective way to teach computational biology is to combine multiple forms of example-based learning \citep{renkl_learning_2014}.
For example, an instructor might use all three methods detailed below:
first show students some written examples, perhaps in pre-reading for a class, then use live coding during class and have the students follow along, and subsequently have students complete a series of examples with increasing amounts of code that students need to fill in during in-class problem sets or in homework assignments.
%\sarah{I rewrote the text about the cognitive apprenticeship to better convey the point.} \rs{I agree}
%Using all three of the methods detailed in this section follows the `cognitive apprenticeship' model of teaching, in which students first observe the way their instructor solves a problem (written examples), then follow along with the instructor to scaffold how to arrive the solution themselves (live coding) \rs{this isn't how I think of live-coding, which would be following along with the instructor}, and ultimately having the instructor fade into the background to allow learners to arrive at the solution on their own (faded examples) \rs{faded examples are a bit more like fill in the blank and not to do with the instructor fading out - this is more independent problem solving but more supported than starting from scratch} (Raj et al. 2018). 



\subsubsection{Written examples}

Written examples are often a good starting point to introduce learners to the concepts and structure of solutions.
Written tutorials allow students to go at their own pace.
This ensures students take the time they need.
However, learners frequently skim over static written examples, confident that they understand what the code is doing, without critically evaluating the code or skipping formative assessment questions, thus not truly ensuring their understanding.
For this reason, written examples are most effective when integrated with other example-based learning methods \citep{renkl_learning_2014}.


\subsubsection{Live coding}\label{Livecoding}

Live coding is a form of example-based learning in which learners watch the instructor solve problems and the learners follow along. 
In most cases, learners are expected to code along with the instructors. 
The act of typing along forces learners to actively enter code, which is a hands-on version of a worked example.
This means the instructor goes at a reasonable pace that learners can follow.
The instructor can stop and ask students challenge questions as formative assessment to ensure that students apply their knowledge immediately and question their own understanding. 
The instructor can also set up a problem, and pause to have students figure out the rest of the exercise. 
This live coding approach has been popularized by Data Carpentry and similar coding workshops.
Live coding can help teach aspects of programming that are not easily taught by viewing static code, such as incremental coding (writing a few lines and testing them) and debugging. 
From the perspective of the learners, live coding is generally preferable to viewing static code, especially when students are able to code along with instructors \citep{raj_role_2018}.


Disadvantages of live coding include that everyone goes at the same pace.
This may be too fast for some and too slow for others.
One possibility to alleviate these disadvantages is to flip the classroom and provide students with pre-recorded live-coding experiences, and then students come to class where they complete an exercise or a series of faded examples. 


\subsubsection{Faded examples}\label{Fillable} 
%there's a term for this - faded examples
%https://openlearning.mit.edu/mit-faculty/research-based-learning-findings/worked-and-faded-examples
%"Faded worked examples are similar to worked examples but fade out steps for students to complete, allowing support within the problem solving approach as learning improves. ... The concept behind faded worked examples is learning from scaffolding, where support is provided to learners but removed, or faded, as the learners’ skill improve (Atkinson, Renkl, & Merrill, 2003)." Hesser and Gregory
%self-correction is used in Montessori teaching so probably has some lit behind it
%\aw{This is really cool! I didn't know there is a name for this}
Faded examples are a form of example-based learning that can be more effective than static worked examples \citep{schwonke_worked-example_2009}.
Faded examples include sets of worked examples, beginning with a complete example. 
With each subsequent example, key problem solving steps are removed and learners must insert the steps themselves \citep{renkl_toward_2014}. 
Faded examples have been demonstrated to require less learning time with potentially better learning outcomes \citep{schwonke_worked-example_2009}. 

In the context of teaching computation to biologists, faded examples are particularly facilitated by servers.
For example, a Jupyter notebook containing faded examples may be made available to students on the server.
If students successfully complete the code they will produce an expected outcome, thus allowing for the student to self-correct their work.
Fillable Jupyter notebooks using the faded examples technique force learners to engage with the material and actively problem-solve. 
Fillable notebooks are particularly useful because they run the code and allow the student to immediately discover if they produced the right answer. 
This type of immediate feedback allows the student to work towards the correct answer, rather than turning in work that they believe to be correct and receiving a low grade on something they put time and effort into.
An important component is providing learners with a solution set after they have had the opportunity to solve the faded examples so that they can see where they went wrong if they are unsuccessful.
%\rs{the cool thing about faded examples in coding (compared to math) is that if it runs and produces the right answer then the student knows they did it right - it's self-correcting rather than teacher-corrected and the student can work toward the correct answer rather than think they got it right and then get a bad grade}
%\sarah{Great point! I've added it to the text.}

\subsection{Focusing on coding as problem-solving}
%\rs{this seems tangential to computing platforms/computing platforms and even to teaching students how to code - as much as I appreciate the ideas in here I don't think they fit in this paper}
%\sarah{That's fair -- this bit came from a small comment from Brian O'Meara during iEvoBio and does not necessarily belong in the paper. It could also be condensed and added under "other challenges and tools" below}
\rs{I think I'm good with leaving it in now given changes to the overall paper, and I added a couple of sentences. It might be more motivational and go earlier in the paper rather than here in teaching methods.}

One of the main skills underlying learning to code is learning how to solve problems. 
Writing code can be viewed as a method of communicating to the computer the precise steps of the analysis.
In fact, code serves as a written record of the analytical steps, and is one that is instantly reproducible.
%In some cases, learning the proper syntax of a given language causes an additional barrier to learners.
When the learning outcomes are not necessarily tied to learners having full mastery of a specific language's syntax, shorthand notation can be used to outline the steps the learner would take to get to the end result, removing the added layer of correct syntax and highlighting the importance of the problem-solving elements.
This method, called pseudocode, can help learners logically scaffold their thought process, and therefore their code, regardless of which language they will be coding in.
Learners can be required to write the solution to their problem in pseudocode to demonstrate their thought process, and then use that pseudocode to write their code \citep[e.g.,][]{olsen_using_2005}.
Courses may rely on pseudocode during timed exams to relieve exam stress.
Note, however, that pseudocode written by different examiners may differ in its adherence to unwritten language rules, and thus could cause confusion among learners \citep{cutts_code_2014}. 
A better approach is to use a formalized pseudocode, where the meaning behind each word is clearly and unambiguously defined \citep{cutts_code_2014}.
\rs{not sure about these last two sentences}

\subsection{Cooperative Learning} 
%\sarah{I re-named this from pair-based learning to cooperative learning to include group work}
\sarah{One of these examples comes from iEvoBio and the other is from one of my colleagues.
If anyone has examples from their teaching they want to highlight/add, please do so!}

Working in groups or pairs (called `cooperative learning'), can result in numerous positive outcomes in the biological sciences, including enhancing scientific thinking and attitudes about biology, aiding in the instruction and evaluation of course material, providing a better understanding of practical skills and their applicability in real-world environments, improving reading, writing, and social skills, and supporting learning for a broader array of students \citep[reviewed in][]{lord_101_2001}. \rs{could also cite Treisman here}
In the context of teaching computational biology, group projects and other forms of cooperative learning have frequently been used to facilitate example-based learning  \citep[e.g.,][]{emery_application_2017,korcsmaros_teaching_2013,fuselier_trace_2011}.
One creative cooperative learning teaching tool for computational biology is pairing students up and having one student be the `driver', who types in the code, and one be the `navigator', who has to tell the driver what to type. 
This exercise forces students to think carefully about the process of creating code.
Even if students are not expected to work through examples or produce a project in pairs or groups, cooperative learning can still be implemented by facilitating discussion and collaboration among students.
This can be done in class (e.g., through think-pair-share exercises, in which students are encouraged to think about a problem individually, then discuss in pairs or small groups) or outside of class through discussion forums.
For instance, students could be encouraged or required to participate in discussions on the course website (e.g., Blackboard/Moodle) or a Slack workspace created for the class, or to do peer review of other students' projects. 
Learning from other students can be a powerful way to get students engaged with the course work, and can solidify their understanding by having them teach each other \citep{treisman1992studying}.

However, as most students and instructors know, group work can create problems and strife.
Interpersonal issues within pairs or groups can hinder the learning process.
Sometimes groups or pairs are unbalanced with regard to prior knowledge, speed of learning, or effort contributed to the project.
Additionally, group size or composition can lead to an entire group struggling to succeed \citep[e.g.,][]{compeau_establishing_2019}. 
\rs{this seems like a whole topic unto itself that probably has a lot of literature - perhaps we can simply refer the reader to that given what you've pointed out here}

Therefore, although group projects are frequently used in computational biology and can be a useful tool, relying only on group-based projects for critical assessments in a course may not be the best solution.

%\rs{I love the idea of pair-based but I wonder if it has to be handled carefully - perhaps a pair are both struggling and therefore this doesn't help - perhaps one of the pair is more advanced and does all the work or becomes impatient}
%\sarah{I added some caveats but I'm happy for others to contribute to this section as well}


\subsection{Other challenges and tools}

Incorporating computational biology into the classroom comes with additional challenges that may not be present in other biology courses.
Many students will have some prior biological knowledge but have no experience with computer coding.
This creates a situation where students have many questions but often feel out of their comfort zone, or are simply uninterested in the computational components of the course material.
These factors combine result in a number of different challenges for instructors to help students successfully navigate the computational side of a biology course.
%\rs{perhaps say something about lack of interest here - they come for biology and force them to code, but see below}

\subsubsection{Demonstrating value}
%\aw{Maybe we want to call this section "Reticence and Computation" or "Demonstrating value" or similar"} 
%\sarah{I like that suggestion! I've now changed the section title to "Demonstrating value"}
%RSS: this is definitely how we sell coding to intro bio and I think it helps with buy-in
The unfamiliarity of coding can sometimes lead the students to push back against the idea of learning to code.
In our experience, demonstrating how coding can be a useful tool for doing the same analysis multiple times (e.g., generate the same type of plot for different datasets) helps students get on board with learning to code. 
This demonstration is especially powerful when the students are enabled to discover the utility of coding on their own. 
For example, an instructor could provide students with a large dataset and encourage the students to try basic analyses (e.g., producing summary statistics or basic plots) in both R and Excel. 
%\rs{even more than this - self-discovery ie here's a big dataset and discover how much better it is not to do this in excel - is stronger than demonstration}
%\sarah{This is an excellent point. I've tried to incorporate it above, but feel free to edit}
Particularly when students have not opted into learning computational skills -- for example, when computational skills are incorporated into introductory biology classrooms -- showing students the value of saving future time and effort is very important. 


\subsubsection{Teaching how to ask for help}
Not all learners will automatically ask for help (see call out box above). 
As instructors, we need to encourage students to seek our help when they are struggling.
One method we have found successful is to provide students with rewards for asking for help, such as an automatic extension on deadlines if students attend office hours.
Having knowledgeable teaching assistants or support staff to go around and check on student progress during in-class exercises is also really helpful.
Instructing TAs to first approach students who do not have their hands raised will provide help to a larger proportion of the class, especially many learners who need the most help.
Data Carpentry uses post-it notes to discreetly signal to instructors when students need assistance.
Incorporating live coding into lectures is another way to normalize asking for help; while live coding, instructors can demonstrate that errors are a natural part of coding, how to effectively search for solutions to problems, and how to look up syntax details.

\subsubsection{Large class sizes}

For instructors who are looking to incorporate computational biology into large classes, such as in an introductory biology course, the prospect of testing and grading code turned in as assignments may be daunting. 
We have found that relying on knowledgeable TAs, support staff, and demonstrators is the best way to ensure that all students receive the help that they need.
Placing students in pairs or small working groups (see the section on Cooperative Learning above) can also provide students with support and feedback that will facilitate their learning, without placing the entire burden on instructors and TAs.
Additionally, relying on IT support to help manage the computing platforms can reduce the workload for the instructors.
Furthermore, using assignments that can be automatically graded (e.g., mimir classroom, https://www.mimirhq.com/) will help reduce the time teachers must spend grading.



\subsubsection{Plagiarism}
Writing code is more similar to math than to writing, as there is a correct answer (or perhaps several correct answers), and it can be difficult to detect whether students arrived at that answer independently or through copying someone else's solution.
Plagiarism is can be exacerbated by the common phenomenon of searching for solutions to a given problem online and copying or adapting posted solutions without attributing proper credit \citep{gaspar_restoring_2007}. 
One approach to ensure students understand code is to require commented explanation of each component of their code, and ensure these comments are different for each student.
Some of the programs that grade code include plagiarism detection components \citep{pears_survey_2007}, which can help instructors identify when plagiarism has occurred.
Instructors are encouraged to discuss these issues and reinforce the importance of citing sources.
Another approach is to allow students to work on assessments as a group, but have each student write out their own pseudocode explanations of the code.
In class quizzes may also use faded examples and require comments,
especially as it is widely accepted that learners should be able to search for the functions
and arguments to functions that are needed to implement their analytical work.
%\rs{it's like math rather than writing - there's a right answer and often it's hard to detect whether someone got their independently or by copying - Linda might have thoughts on this} \sarah{I added this comparison to the paragraph}

\section{Conclusions}

Computing is increasingly being incorporated into coursework at all levels in biology.
Computing is both a key skill for learners and supports additional learning by enabling the incorporation of data and analysis into classrooms. 
Instructors have a range of choices in front of them for how to deliver computational lessons.
From the computing platform to how the instructor delivers the lesson, every aspect of a computational classroom can shape learners' knowledge and confidence. 
In this paper, we have outlined the costs and benefits of several popular computing platforms.
Given the variety of options, instructors should be able to find a platform that best fits their course learning objectives, available resources, class size, and learner backgrounds.
One important consideration in this decision is how the platform of choice affects learner access to course content.
Many of these computing platforms can improve inclusion and diversity in the classroom (and thus, ultimately, in fields and careers that incorporate computation) by providing access to the same technologies to all learners.
We have also discussed several teaching strategies for computational biology and other courses with computation, with the goal of improving student learning and retention.

%Main takeaways: 
%All types of computing platforms have pros and cons.
%The choice of which to use will come from the learning objectives of %he course and the resources available to the instructor
%We have lots of ideas for how to improve diversity and inclusion in computational biology
%Many teaching strategies are available to help ensure students learn what we're trying to teach them.

\bibliographystyle{sysbio}
\bibliography{CST_whitepaper}

